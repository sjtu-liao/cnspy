
Tutorial: Lorenz
=====================

Problem Description
-------------------
As a first tutorial we will use the famous equations Lorenz equations.
The governing ODEs are:

.. math::

    \dot{x}(t) & = \sigma [y(t) - x(t)]

   \dot{y}(t) & = R x(t) - y(t) -x(t)z(t)

   \dot{z}(t) & = x(t)y(t) - b z(t)

where :math:`\sigma, R, b` are physical parameters,  the dot denotes the differentiation with respect to the time :math:`t`, respectively.

Inputing the Lorenz Model
--------------------------

To use `cnspy` generate the cns code, you need to tell `cnspy` what the functions will be calculate.

Firstly, we importing all necessary packages:

.. code-block:: python

    import sympy as sp
    from cnspy import cns
    from cnspy import method

Then, we create the Lorenz equations through `Sympy`.

.. code-block:: python

    t = sp.symbols(r't')
    sigma,R,B = sp.symbols(r'\sigma, R, B')
    u=sp.symarray('x', 3)
    f1=sigma*(u[1]-u[0])
    f2=R*u[0]-u[1]-u[0]*u[2]
    f3=u[0]*u[1]-B*u[2]
    fun=[f1,f2,f3]

Generate CNS C code of Lorenz equations
----------------------------------------

To generate the CNS code, just simply use the cns function:

.. code-block:: python

    lorenz=cns(funcs=fun,name="Lorenz",\
            method=method('TS',order=488,wordsize=3072),\
            inits=[[u[0],"-15.8"],[u[1],"-17.48"],[u[2],"35.64"]],\
            paras=[[sigma,"10"],[R,"28"],[B,"8/3"]],\
            tspan=(0,1000),\
            saveat=10,\
            lyap=0.91,\
            adaptive=adaptive('t','order','wordsize',delta_T=50,remaining_T=500,gamma=1.1),\
            mpi=True,\
            numofprocessor=128)

In this function, we set the method by the `method` class in `cnspy`, and the order of the taylor series and the word size of the all variable is set to be `488` and `3072`. The initial conditions (:math:`x=-15.8`, :math:`y=-17.48`, :math:`z=35.64`) and the parameters (:math:`\sigma=10`, :math:`R=28`, :math:`B=\frac{8}{3}`) are also declared. Besides, the mpi flag is set to be true to generate the mpi version of the CNS code.

.. note::
    The word size of the input is in binary digits, and the word size `3072` will be `924` in decimal digits. The conversion formula is: :math:`P_{dec} = P_{bin}\cdot \lg 2`. It is worth mentioning that the double accuracy is 15 decimal places ( :math:`52\cdot\lg 2=15`).

Finally, the code will be generated by calling the `generate_c_code()`:

.. code-block:: python

    lorenz.generate_c_code()

Running the Lorenz C code
--------------------------

Now, we have create the c code of the Lorenz equations with Taylor method. To run it::

    cd Lorenz/ccode/
    make
    mpirun -n 4 Lorenz

This will calculate the Lorenz equations and print the solutions to the ``Lorenz/ans/`` folder.

Or you can use cnspy.cluster to run the code on the cluster:

.. code-block:: python

    from cnspy import cluster
    HN = cluster.ssh()
    HN.connect()
    SL = cluster.slurm_script(node=HN.idle_node(2), qos='super', np=lorenz.numofprocessor, jobname = lorenz.name)
    SL.clear_script(lorenz.ccodepath)
    SL.write_script(lorenz.ccodepath,mlx4_0=False)
    HN.execute('mkdir -p ~/cnspy_ssh/lorenz63')
    HN.upload_directory(lorenz.parrentpath,'/data01/home/zhangbo/cnspy_ssh/lorenz63')
    HN.execute(f'cd ~/cnspy_ssh/lorenz63/ccode; make; {SL.submit_command()}')
